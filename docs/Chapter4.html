<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>4&nbsp; Chapter 4 - Evolution-Aware BERT: Designing Encoders for Genomics – Biological language models &amp; Neural Networks</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./summary.html" rel="next">
<link href="./Chapter3.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-687258f6a899824ebad24e93c100d594.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Biological language models &amp; Neural Networks</span>
    </a>
  </div>
        <div class="quarto-navbar-tools tools-end">
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
          <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./Chapter1.html">DNA</a></li><li class="breadcrumb-item"><a href="./Chapter4.html"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Chapter 4 - Evolution-Aware BERT: Designing Encoders for Genomics</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">DNA</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Preparing DNA data for training</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Training our first DNA Language Model</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Evaluating DNA Language Models</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter4.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Chapter 4 - Evolution-Aware BERT: Designing Encoders for Genomics</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./summary.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Summary</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction"><span class="header-section-number">4.1</span> Introduction</a></li>
  <li><a href="#tokenization-and-embedding-in-language-models" id="toc-tokenization-and-embedding-in-language-models" class="nav-link" data-scroll-target="#tokenization-and-embedding-in-language-models"><span class="header-section-number">4.2</span> 1. Tokenization and Embedding in Language Models</a>
  <ul class="collapse">
  <li><a href="#tokenization-in-natural-language" id="toc-tokenization-in-natural-language" class="nav-link" data-scroll-target="#tokenization-in-natural-language"><span class="header-section-number">4.2.1</span> Tokenization in Natural Language</a></li>
  <li><a href="#the-embedding-process-nlp-bert" id="toc-the-embedding-process-nlp-bert" class="nav-link" data-scroll-target="#the-embedding-process-nlp-bert"><span class="header-section-number">4.2.2</span> The Embedding Process (NLP BERT)</a></li>
  <li><a href="#language-evolution-is-decayed" id="toc-language-evolution-is-decayed" class="nav-link" data-scroll-target="#language-evolution-is-decayed"><span class="header-section-number">4.2.3</span> Language Evolution is Decayed</a></li>
  </ul></li>
  <li><a href="#biological-sequences-are-fundamentally-different" id="toc-biological-sequences-are-fundamentally-different" class="nav-link" data-scroll-target="#biological-sequences-are-fundamentally-different"><span class="header-section-number">4.3</span> 2. Biological Sequences are Fundamentally Different</a>
  <ul class="collapse">
  <li><a href="#key-differences-between-language-and-dna" id="toc-key-differences-between-language-and-dna" class="nav-link" data-scroll-target="#key-differences-between-language-and-dna"><span class="header-section-number">4.3.1</span> Key Differences Between Language and DNA</a></li>
  <li><a href="#evolution-is-a-rich-context-layer" id="toc-evolution-is-a-rich-context-layer" class="nav-link" data-scroll-target="#evolution-is-a-rich-context-layer"><span class="header-section-number">4.3.2</span> Evolution is a Rich Context Layer</a></li>
  </ul></li>
  <li><a href="#encoding-genomes-with-evolution-in-mind" id="toc-encoding-genomes-with-evolution-in-mind" class="nav-link" data-scroll-target="#encoding-genomes-with-evolution-in-mind"><span class="header-section-number">4.4</span> 3. Encoding Genomes with Evolution in Mind</a></li>
  <li><a href="#introducing-gpn-bert" id="toc-introducing-gpn-bert" class="nav-link" data-scroll-target="#introducing-gpn-bert"><span class="header-section-number">4.5</span> 4. Introducing GPN-BERT</a>
  <ul class="collapse">
  <li><a href="#key-idea-dynamic-position-embeddings" id="toc-key-idea-dynamic-position-embeddings" class="nav-link" data-scroll-target="#key-idea-dynamic-position-embeddings"><span class="header-section-number">4.5.1</span> Key Idea: Dynamic Position Embeddings</a></li>
  <li><a href="#visualization" id="toc-visualization" class="nav-link" data-scroll-target="#visualization"><span class="header-section-number">4.5.2</span> Visualization</a></li>
  <li><a href="#practical-implementation---replacing-the-bert-encoder" id="toc-practical-implementation---replacing-the-bert-encoder" class="nav-link" data-scroll-target="#practical-implementation---replacing-the-bert-encoder"><span class="header-section-number">4.5.3</span> Practical Implementation - Replacing the BERT Encoder</a></li>
  </ul></li>
  <li><a href="#recap-of-our-approach" id="toc-recap-of-our-approach" class="nav-link" data-scroll-target="#recap-of-our-approach"><span class="header-section-number">4.6</span> 5. Recap of Our Approach</a></li>
  <li><a href="#preview-of-chapter-5" id="toc-preview-of-chapter-5" class="nav-link" data-scroll-target="#preview-of-chapter-5"><span class="header-section-number">4.7</span> 6. Preview of Chapter 5</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references"><span class="header-section-number">4.8</span> References</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./Chapter1.html">DNA</a></li><li class="breadcrumb-item"><a href="./Chapter4.html"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Chapter 4 - Evolution-Aware BERT: Designing Encoders for Genomics</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Chapter 4 - Evolution-Aware BERT: Designing Encoders for Genomics</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Abstract
</div>
</div>
<div class="callout-body-container callout-body">
<p>I this chapter we’ll evaluate the architecture of natural language models, which we have up to this point uncritically adopted for DNA modeling from our NLP/corporate brethern. We’ll discuss how some reseachers have bugun to move on from applying known model architectures to DNA and started to (re)designing model architectures specifically with DNA in mind. These models lean into our very extensive knowledge of the evolutionary history of the Genome.</p>
<p>All scripts for this chapter are found here: <a href="https://github.com/MichelNivard/Biological-language-models/tree/main/scripts/Chapter_4" class="uri">https://github.com/MichelNivard/Biological-language-models/tree/main/scripts/Chapter_4</a></p>
</div>
</div>
<section id="introduction" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="introduction"><span class="header-section-number">4.1</span> Introduction</h2>
<p>In previous chapters, we introduced the basic principles of <strong>BERT for DNA sequences</strong>. We took inspiration from natural language processing (NLP), treating DNA as a <strong>language</strong>, where sequences of nucleotides (A, T, C, G, -) could be processed using transformers. This approach, while powerful, carries over several assumptions from natural language that do not perfectly align with biological sequences. In this chapter, we will re-examine how we encode genomic data and introduce <strong>a new design paradigm — evolutionary-aware encoding — inspired by the recently proposed GPN (Genomic Pre-trained Network).</strong></p>
<hr>
</section>
<section id="tokenization-and-embedding-in-language-models" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="tokenization-and-embedding-in-language-models"><span class="header-section-number">4.2</span> 1. Tokenization and Embedding in Language Models</h2>
<p>Modern language models, whether <strong>BERT</strong>, <strong>GPT</strong>, or similar architectures, rely heavily on <strong>how input sequences are tokenized and encoded before they ever reach the attention layers</strong>. This initial step — often overlooked — plays a profound role in shaping how the model learns.</p>
<section id="tokenization-in-natural-language" class="level3" data-number="4.2.1">
<h3 data-number="4.2.1" class="anchored" data-anchor-id="tokenization-in-natural-language"><span class="header-section-number">4.2.1</span> Tokenization in Natural Language</h3>
<p>In human languages like English or French, the vocabulary is <strong>large</strong>, often comprising tens of thousands of tokens. These tokens could be:</p>
<ul>
<li>Whole words (“cat”, “sat”).</li>
<li>Subwords (“cat” might break into “c”, “at”).</li>
<li>Even characters (in rare cases).</li>
</ul>
<p>Since the number of tokens is so large, <strong>each token is assigned a unique vector embedding — a dense, learnable representation of its “meaning”</strong>. These embeddings are gradually refined during training as the model learns how tokens behave in different contexts.</p>
</section>
<section id="the-embedding-process-nlp-bert" class="level3" data-number="4.2.2">
<h3 data-number="4.2.2" class="anchored" data-anchor-id="the-embedding-process-nlp-bert"><span class="header-section-number">4.2.2</span> The Embedding Process (NLP BERT)</h3>
<pre><code>Input Sentence:  "The cat sat on the mat"

Step 1 - Tokenization:
    ["The", "cat", "sat", "on", "the", "mat"]

Step 2 - Lookup:
    Each token gets a fixed vector from an embedding table.

    "The" -&gt; [0.25, 0.13, -0.11, ..., 0.04]
    "cat" -&gt; [0.88, -0.23, 0.45, ..., -0.67]

Step 3 - Transformer Layers:
    These embeddings are updated based on surrounding words (context).</code></pre>
</section>
<section id="language-evolution-is-decayed" class="level3" data-number="4.2.3">
<h3 data-number="4.2.3" class="anchored" data-anchor-id="language-evolution-is-decayed"><span class="header-section-number">4.2.3</span> Language Evolution is Decayed</h3>
<p>The design of these token embeddings reflects a key fact about human languages: <strong>the evolutionary history of words is largely irrelevant to understanding their meaning today</strong>. While linguistic etymology exists, the meaning of “cat” today does not rely on whether the word originated from Latin or Proto-Indo-European. <strong>Context (the words around “cat”) matters far more than distant etymology.</strong></p>
<hr>
</section>
</section>
<section id="biological-sequences-are-fundamentally-different" class="level2" data-number="4.3">
<h2 data-number="4.3" class="anchored" data-anchor-id="biological-sequences-are-fundamentally-different"><span class="header-section-number">4.3</span> 2. Biological Sequences are Fundamentally Different</h2>
<p>In genomics, this assumption breaks down. Each nucleotide (A, T, G, C, -) has a <strong>fixed biochemical meaning</strong>, but its biological relevance <strong>depends profoundly on its evolutionary history across species</strong>.</p>
<section id="key-differences-between-language-and-dna" class="level3" data-number="4.3.1">
<h3 data-number="4.3.1" class="anchored" data-anchor-id="key-differences-between-language-and-dna"><span class="header-section-number">4.3.1</span> Key Differences Between Language and DNA</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th>Aspect</th>
<th>Natural Language</th>
<th>Genomics</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Number of Tokens</td>
<td>Tens of thousands</td>
<td>~5 (A, T, G, C, -)</td>
</tr>
<tr class="even">
<td>Meaning</td>
<td>Flexible, evolves over time</td>
<td>Biochemically fixed</td>
</tr>
<tr class="odd">
<td>Evolutionary Context</td>
<td>Mostly irrelevant to meaning</td>
<td>Often crucial (conservation, divergence)</td>
</tr>
<tr class="even">
<td>Token Embedding</td>
<td>Fully learned</td>
<td>Can be partly predefined (one-hot)</td>
</tr>
<tr class="odd">
<td>Neighboring Context</td>
<td>Defines meaning</td>
<td>Defines local motifs, but evolutionary context adds extra layer</td>
</tr>
</tbody>
</table>
</section>
<section id="evolution-is-a-rich-context-layer" class="level3" data-number="4.3.2">
<h3 data-number="4.3.2" class="anchored" data-anchor-id="evolution-is-a-rich-context-layer"><span class="header-section-number">4.3.2</span> Evolution is a Rich Context Layer</h3>
<p>The <strong>evolutionary history of a genomic position — how conserved it is, how it varies across species — directly influences its biological function</strong>. A nucleotide in a highly conserved enhancer region means something different from a nucleotide in a rapidly evolving spacer.</p>
<hr>
</section>
</section>
<section id="encoding-genomes-with-evolution-in-mind" class="level2" data-number="4.4">
<h2 data-number="4.4" class="anchored" data-anchor-id="encoding-genomes-with-evolution-in-mind"><span class="header-section-number">4.4</span> 3. Encoding Genomes with Evolution in Mind</h2>
<p>To capture this <strong>cross-species evolutionary context</strong>, we need an <strong>embedding strategy that combines:</strong></p>
<ol type="1">
<li><strong>The identity of the nucleotide itself (A, T, G, C, -)</strong>.</li>
<li><strong>The state of this position in aligned species (what bases appear at the same position in other species).</strong></li>
</ol>
<p>This evolutionary-aware encoding is at the heart of the <strong>Genomic Pre-trained Network (GPN)</strong> architecture.</p>
<hr>
</section>
<section id="introducing-gpn-bert" class="level2" data-number="4.5">
<h2 data-number="4.5" class="anchored" data-anchor-id="introducing-gpn-bert"><span class="header-section-number">4.5</span> 4. Introducing GPN-BERT</h2>
<p>GPN-BERT (inspired by Benegas et al., 2024) adapts BERT-style masked language modeling (MLM) to DNA sequences, but <strong>incorporates multispecies alignment (MSA) data directly into the model’s input</strong>.</p>
<section id="key-idea-dynamic-position-embeddings" class="level3" data-number="4.5.1">
<h3 data-number="4.5.1" class="anchored" data-anchor-id="key-idea-dynamic-position-embeddings"><span class="header-section-number">4.5.1</span> Key Idea: Dynamic Position Embeddings</h3>
<p>For each position in the human genome, the model receives:</p>
<ul>
<li>The <strong>human base (A, T, G, C, -)</strong> — this is the usual input.</li>
<li>The <strong>aligned bases from other species</strong> — these are additional features.</li>
<li>These aligned bases are <strong>one-hot encoded</strong> and concatenated to the human base’s embedding.</li>
</ul>
<p>This turns a <strong>simple nucleotide (A)</strong> into a <strong>dynamic, position-specific vector</strong> that depends on its <strong>evolutionary context across species</strong>.</p>
</section>
<section id="visualization" class="level3" data-number="4.5.2">
<h3 data-number="4.5.2" class="anchored" data-anchor-id="visualization"><span class="header-section-number">4.5.2</span> Visualization</h3>
<pre><code>Human Position:     A
Aligned Species:    A  G  A  (species 1, species 2, species 3)

Embedding:
    [ OneHot_A | OneHot_A | OneHot_G | OneHot_A ]</code></pre>
<p>This combined vector captures:</p>
<ul>
<li>What the human base is.</li>
<li>How conserved the site is.</li>
<li>Which substitutions are tolerated across species.</li>
</ul>
<hr>
</section>
<section id="practical-implementation---replacing-the-bert-encoder" class="level3" data-number="4.5.3">
<h3 data-number="4.5.3" class="anchored" data-anchor-id="practical-implementation---replacing-the-bert-encoder"><span class="header-section-number">4.5.3</span> Practical Implementation - Replacing the BERT Encoder</h3>
<p>To implement this in practice, we can directly modify a Hugging Face model class (like <code>ModernBertForMaskedLM</code>) to use our custom <strong>GPNEmbedding</strong> layer in place of the standard token embedding layer.</p>
<p>This requires:</p>
<ul>
<li>Defining a <strong>GPNEmbedding</strong> class that concatenates the one-hot human base with species features.</li>
<li>Subclassing <code>ModernBertForMaskedLM</code> to replace the embedding layer.</li>
<li>Ensuring the <code>forward</code> method accepts both <code>input_ids</code> and <code>aux_features</code>, which are passed into the embedding layer.</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> GPNEmbedding(nn.Module):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, config, n_species):</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.config <span class="op">=</span> config</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.n_species <span class="op">=</span> n_species</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.vocab_size <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.species_feature_size <span class="op">=</span> <span class="va">self</span>.n_species <span class="op">*</span> <span class="va">self</span>.vocab_size</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, input_ids, aux_features):</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        one_hot <span class="op">=</span> F.one_hot(input_ids, num_classes<span class="op">=</span><span class="va">self</span>.config.vocab_size).<span class="bu">float</span>()</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        combined <span class="op">=</span> torch.cat([one_hot[..., :<span class="va">self</span>.vocab_size], aux_features], dim<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> combined.shape[<span class="op">-</span><span class="dv">1</span>] <span class="op">&lt;</span> <span class="va">self</span>.config.hidden_size:</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>            combined <span class="op">=</span> F.pad(combined, (<span class="dv">0</span>, <span class="va">self</span>.config.hidden_size <span class="op">-</span> combined.shape[<span class="op">-</span><span class="dv">1</span>]))</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> combined</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ModernBertForMaskedLMWithGPN(ModernBertForMaskedLM):</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, config, n_species):</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>(config)</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.gpn_embedding <span class="op">=</span> GPNEmbedding(config, n_species)</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, input_ids<span class="op">=</span><span class="va">None</span>, aux_features<span class="op">=</span><span class="va">None</span>, <span class="op">**</span>kwargs):</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>        embeddings <span class="op">=</span> <span class="va">self</span>.gpn_embedding(input_ids, aux_features)</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>        outputs <span class="op">=</span> <span class="va">self</span>.bert.encoder(inputs_embeds<span class="op">=</span>embeddings, <span class="op">**</span>kwargs)</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>        logits <span class="op">=</span> <span class="va">self</span>.cls(outputs[<span class="dv">0</span>])</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> {<span class="st">'logits'</span>: logits}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This illustrates how <strong>pre-trained transformers can be adapted for genomics</strong> while preserving compatibility with Hugging Face’s <code>Trainer</code> ecosystem.</p>
<hr>
</section>
</section>
<section id="recap-of-our-approach" class="level2" data-number="4.6">
<h2 data-number="4.6" class="anchored" data-anchor-id="recap-of-our-approach"><span class="header-section-number">4.6</span> 5. Recap of Our Approach</h2>
<p>In <strong>Chapter 2</strong>, we trained a vanilla <strong>BERT</strong> on DNA sequences alone — treating DNA as just another language. That model only had access to the <strong>human sequence</strong>, with no evolutionary context.</p>
<p>In <strong>this chapter</strong>, we’ve reimagined that process. Instead of treating A, T, G, C, - as abstract symbols, we inject <strong>evolutionary history directly into the input encoding</strong>. This allows our model to:</p>
<ul>
<li>Use the aligned species data as <strong>a rich evolutionary prior</strong>.</li>
<li>Still leverage transformers for learning <strong>sequence motifs</strong>.</li>
<li>Predict masked human bases using both <strong>local sequence</strong> and <strong>cross-species evolutionary patterns</strong>.</li>
</ul>
<hr>
</section>
<section id="preview-of-chapter-5" class="level2" data-number="4.7">
<h2 data-number="4.7" class="anchored" data-anchor-id="preview-of-chapter-5"><span class="header-section-number">4.7</span> 6. Preview of Chapter 5</h2>
<p>In <strong>Chapter 5</strong>, we will put these two models — <strong>Vanilla BERT</strong> and <strong>GPN-BERT</strong> — to the test. We will evaluate their performance on:</p>
<ul>
<li>Predicting masked bases (MLM accuracy).</li>
<li>Identifying regulatory elements.</li>
<li>Predicting the functional impact of mutations.</li>
</ul>
<p>This head-to-head comparison will highlight the <strong>strengths and weaknesses</strong> of each approach and show the value of embedding <strong>evolutionary context directly into genomic language models</strong>.</p>
<hr>
</section>
<section id="references" class="level2" data-number="4.8">
<h2 data-number="4.8" class="anchored" data-anchor-id="references"><span class="header-section-number">4.8</span> References</h2>
<ul>
<li>Benegas et al., <em>Nature Biotechnology</em>, 2024.<br>
<a href="https://doi.org/10.1038/s41587-024-02511-w">A DNA language model based on multispecies alignment predicts the effects of genome-wide variants</a></li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./Chapter3.html" class="pagination-link" aria-label="Evaluating DNA Language Models">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Evaluating DNA Language Models</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./summary.html" class="pagination-link" aria-label="Summary">
        <span class="nav-page-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Summary</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>